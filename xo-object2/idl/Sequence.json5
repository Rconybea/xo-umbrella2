{
    mode: "facet",
    output_cpp_dir: "src/object2",
    includes: ["<xo/gc/GCObject.hpp>"],
    // extra includes in Sequence.hpp, if any
    user_hpp_includes: [],
    namespace1: "xo",
    namespace2: "scm",
    // text after includes, before ASequence
    pretext: [ "// {pretext} here" ],
    facet: "Sequence",
    detail_subdir: "sequence",
    brief: "an ordered collection of variants",
    using_doxygen: true,
    doc: [
        "Elements appear in some determinstic order.",
        "Sequence is GC-aware --> elements must be GC-aware"
    ],
    types: [
        // using size_type = std::size_t
        {
            name: "size_type",
            doc: ["type for length of a sequence"],
            definition: "std::size_t",
        },
        // using AGCObject = xo::mm::AGCObject
        {
            name: "AGCObject",
            doc: ["facet for types with GC support"],
            definition: "xo::mm::AGCObject",
        }
    ],
    const_methods: [
        // bool is_empty() const noexcept
        {
            name: "is_empty",
            doc: ["true iff sequence is empty"],
            return_type: "bool",
            args: [],
            const: true,
            noexcept: true,
            attributes: [],
        },

        // bool is_finite() const noexcept
        {
            name: "is_finite",
            doc: ["true iff sequence is finite"],
            return_type: "bool",
            args: [],
            const: true,
            noexcept: true,
            attributes: [],
        },

        // obj<AGCObject> at(size_type index) const;
        {
            name: "at",
            doc: ["return element @p index of this sequence"],
            return_type: "obj<AGCObject>",
            args: [
                {type: "size_type", name: "index"},
            ],
            const: true,
            noexcept: false,
            attributes: [],
        },
    ],
    nonconst_methods: [
    ],
    router_facet_explicit_content: []
}
